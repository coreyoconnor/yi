{-# LANGUAGE DeriveDataTypeable #-}

module Yi.Tab
 (
  Tab,
  tabActivities,
  TabRef,
  tabActivitiesA,
  addActivity,
  currentActivityA,
  tabLayoutManagerA,
  tabDividerPositionA,
  tkey,
  tabMiniWindows,
  tabWindows,
  mapTabWindows,
  tabFocus,
  forceTab,
  mapTabActivities,
  tabLayout,
  tabFoldl,
  makeTab,
  makeTab1,
  lookupActivityGroup
 )  where

import qualified Prelude
import Yi.Prelude

import qualified Data.Binary as Binary
import Data.Accessor.Basic
import Data.Monoid ( First(..) )
import qualified Data.List.PointedList as PL

import Yi.ActivityGroup
import Yi.Layout
import Yi.Window

type TabRef = Int

-- | A tab, containing a collection of windows.
data Tab = Tab {
  tkey             :: !TabRef,                                     -- ^ For UI sync; fixes #304
  tabActivities    :: !(PL.PointedList ActivityGroup),         -- ^ The focus list of the activities. 
  tabLayout        :: !(Layout ActivityGroupRef),      -- ^ Current layout. Invariant: must be the layout generated by 'tabLayoutManager', up to changing the 'divPos's.
  tabLayoutManager :: !AnyLayoutManager -- ^ layout manager (for regenerating the layout when we add/remove activities)
  }
 deriving Typeable

instance NFData Tab where
    rnf t@(Tab {}) =       rnf (tkey t) 
                     `seq` rnf (tabActivities t)
                     `seq` rnf (tabLayout t)

tabFocus :: Tab -> ActivityGroup
tabFocus = PL.focus . tabActivities

-- | Returns a list of all mini windows in the given tab
tabMiniWindows :: Tab -> [Window]
tabMiniWindows = concatMap (Prelude.filter isMini . toList . groupActivities) . toList . tabActivities

-- | Accessor for the activity groups. If the groups (but not the focus) have changed when setting,
-- then a relayout will be triggered to preserve the internal invariant.
tabActivitiesA :: Accessor Tab (PL.PointedList ActivityGroup)
tabActivitiesA = fromSetGet setter getter
  where
    setter ag t = relayoutIf (toList ag /= toList (tabActivities t)) (t { tabActivities = ag})
    getter = tabActivities

addActivity :: AddSide -> ActivityGroup -> Tab -> Tab
addActivity AddRight a = modify tabActivitiesA (PL.insertRight a)
addActivity AddLeft a = modify tabActivitiesA (PL.insertLeft a)

currentActivityA :: Accessor Tab ActivityGroup
currentActivityA = PL.focusA . tabActivitiesA

-- | All the windows in the tab in a list. 
tabWindows :: Tab -> [ Window ]
tabWindows = concatMap (toList . groupActivities) . toList . tabActivities

-- | Modify all the windows with the given function.
mapTabWindows :: ( Window -> Window ) -> Tab -> Tab
mapTabWindows f tab = tab { tabActivities = fmap (mapGroupWindows f) $ tabActivities tab }

-- | Accessor for the layout manager. When setting, will trigger a relayout if the layout manager has changed.
tabLayoutManagerA :: Accessor Tab AnyLayoutManager
tabLayoutManagerA = fromSetGet setter getter
  where
    setter lm t = relayoutIf (lm /= tabLayoutManager t) (t { tabLayoutManager = lm })
    getter = tabLayoutManager

-- | Gets / sets the position of the divider with the given reference. The caller must ensure that the DividerRef is valid, otherwise an error will (might!) occur.
tabDividerPositionA :: DividerRef -> Accessor Tab DividerPosition
tabDividerPositionA ref = dividerPositionA ref . fromSetGet (\l t -> t { tabLayout = l}) tabLayout

relayoutIf :: Bool -> Tab -> Tab
relayoutIf False t = t
relayoutIf True t = relayout t

relayout :: Tab -> Tab
relayout t = t { tabLayout = buildLayout (tabActivities t) (tabLayoutManager t) (tabLayout t) }

instance Binary.Binary Tab where
  put (Tab tk gs _ _) = Binary.put tk >> Binary.put gs
  get = makeTab <$> Binary.get <*> Binary.get


-- | Equality on tab identity (the 'tkey')
instance Eq Tab where
  (==) t1 t2 = tkey t1 == tkey t2

instance Show Tab where
  show t = "Tab " ++ show (tkey t)

-- | A specialised version of "fmap".
mapTabActivities :: (ActivityGroup -> ActivityGroup) -> Tab -> Tab
mapTabActivities f = modify tabActivitiesA (fmap f)

-- | Forces all windows in the tab
forceTab :: Tab -> Tab
forceTab t = foldr seq t (t ^. tabActivitiesA)

-- | Folds over the activities in the tab
tabFoldl :: (a -> ActivityGroup -> a) -> a -> Tab -> a
tabFoldl f z t = foldl f z (t ^. tabActivitiesA)

-- -- | Run the layout on the given tab, for the given aspect ratio
buildLayout :: PL.PointedList ActivityGroup -> AnyLayoutManager -> Layout ActivityGroupRef -> Layout ActivityGroupRef
buildLayout activityList layoutManager previousLayout 
    = pureLayout layoutManager previousLayout . fmap activityGroupRef . toList $ activityList

-- | Make a tab from multiple windows
makeTab :: TabRef -> PL.PointedList ActivityGroup -> Tab
makeTab key groupList = Tab key groupList (buildLayout groupList initial initial) initial

-- | Make a tab from one window
makeTab1 :: TabRef -> ActivityGroup -> Tab
makeTab1 key activity = makeTab key (PL.singleton activity)

lookupActivityGroup :: ActivityGroupRef -> Tab -> Maybe ActivityGroup
lookupActivityGroup r tab = getFirst $ foldMap (\ag -> if r == activityGroupRef ag 
                                                            then First $ Just ag
                                                            else First Nothing 
                                               ) 
                                               (tabActivities tab)

